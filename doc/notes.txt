Crypto todo (NIK, Signal)
* Use specific algos instead of sodium's generics

NIK todo
* Update counter check to use algorithm in RFC 6479 as in WG-Go
  https://github.com/WireGuard/wireguard-go/blob/master/replay/replay.go
* In Cxn, check if we're triggering on timeouts too often (already acted upon)
  e.g. if (cxn->current.send_n >= NIK_LIMIT_REKEY_AFTER_MESSAGES)
* Lifetime for enqueue payload
* If both A and B initiate a handshake simultaneously what happens?

Signal todo
* Double ratchet header encryption
* Double ratchet memzero?
* Skips: what if they never arrive? just takes up space...
  what if the map becomes full?
* we haven't authenticated when we ratchet? but we're updating state
* One-time prekeys, or alternative anti-replay mechanism
* Consider adding PQXDH: https://signal.org/docs/specifications/pqxdh/
* Use fastrange https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/
  instead of modulus
* Sesame?

kv
* libkv interface
* lmdb impl

key usability
* password-protected key
* read+use ssh-keygen/openssl ed25519 keys

uvco
* uv_close_handle expects the handle to outlive the call, so handle can't be
  stack allocated...

cbase
* implement a mimalloc allocator
* implement a mimalloc arena allocator
* implement a mimalloc fixed-size arena allocator

---

Wireguard go notes

peer.go

timers
retransmitHandshake
sendKeepalive
newHandshake
zeroKeyMaterial
persistentKeepalive
handshakeAttempts uint32
needAnotherKeepalive bool
sentLastMinuteHandhsake bool
persistentKeepaliveInterval uint32


MessageInitiation
MessageResponse
  timersAnyAuthenticatedPacketTraversal
  timersAnyAuthenticatedPacketReceived
MessageResponse
  timersSessionDerived
  timersHandshakeComplete
  sendKeepalive
timersDataSent
timersAnyAuthenticatedPacketSent
timersHandshakeInitiated

Keepalive timeout gets bumped on timersDataReceived

map[PK]Peer


MaxSegmentSize = (1 << 16) - 1  // UDP datagram limit
// Windows: 2048 - 32
// iOS: 1700

MaxTimerHandshakes = RekeyAttemptTime / RekeyTimeout
HandshakeInitiationRate: 20ms

Min/max message sizes

Implement HMAC-based KDF functions like in noise-helpers.go?

Replay + flood prevention
On init message check (ConsumeMessageInititation)
replay := !timestamp.after(handshake.last_timestamp)
flood := time.since(handshake.last_initiation_consumption) <= HandshakeInitiationRate (20ms)

---

