cli
* Consider switching from argparse to optparse
  https://github.com/skeeto/optparse

crypto
* Consider using paseto or similar for stateless capabilities
  https://github.com/paseto-standard/paseto-spec
* Consider using (x)chacha20+blake3 (instead of chacha20+poly1305) for aead
  to add committment to the crypto properties

NIK todo
* Update counter check to use algorithm in RFC 6479 as in WG-Go
  https://github.com/WireGuard/wireguard-go/blob/master/replay/replay.go
* In Cxn, check if we're triggering on timeouts too often (already acted upon)
  e.g. if (cxn->current.send_n >= NIK_LIMIT_REKEY_AFTER_MESSAGES)
* Lifetime for enqueue payload
* If both A and B initiate a handshake simultaneously what happens?
* Review wg-go replay + flood prevention
  On init message check (ConsumeMessageInititation)
  replay := !timestamp.after(handshake.last_timestamp)
  flood := time.since(handshake.last_initiation_consumption) <= HandshakeInitiationRate (20ms)
* Rm use of HMAC Blake2 and just used keyed Blake2? All the KDFs could do this
  Or Implement HMAC-based KDF functions like in wg-go noise-helpers.go?

Signal todo
* Routing - consider using sender/recveiver ids like Wireguard, but maybe
  random each time with a nextid in each message
* Verify counter nonce usage won't repeat (separate tx and rx keys?)
* One-time prekeys, or alternative anti-replay mechanism, maybe borrowing from
  Wireguard
* Out-of-order message support
* Consider adding PQXDH: https://signal.org/docs/specifications/pqxdh/
  https://github.com/open-quantum-safe/liboqs
  ML-KEM, Kyber, FIPS 203
  https://github.com/pq-crystals/kyber
  https://github.com/cryspen/libcrux/tree/main/libcrux-ml-kem
  https://github.com/itzmeanjan/ml-kem
  https://github.com/GiacomoPope/kyber-py
* Sesame session management

kv
* libkv interface
* lmdb impl
* Consider CipherSweet for searchable db
  https://ciphersweet.paragonie.com

key usability
* password-protected key
* read+use ssh-keygen/openssl ed25519 keys

uvco
* consider storing handles in the coroutine frame? instead of malloc

ngtcp2
* Allocator
* Memory management/ownership
* Real crypto
