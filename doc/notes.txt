NIK todo
* compare against wireguard-go
* max timestamp for handshake
* Update counter check to use algorithm in RFC 6479 as in WG-Go
  https://github.com/WireGuard/wireguard-go/blob/master/replay/replay.go

Signal todo
* Fix up key mgmt to use the sodium key conversion functions

kv
* libkv interface
* lmdb impl
* password-protected key

uvco
* uv_close_handle expects the handle to outlive the call, so handle can't be
  stack allocated...

cbase
* implement a mimalloc allocator
* implement a mimalloc arena allocator
* implement a mimalloc fixed-size arena allocator

---

Wireguard go notes

peer.go

timers
retransmitHandshake
sendKeepalive
newHandshake
zeroKeyMaterial
persistentKeepalive
handshakeAttempts uint32
needAnotherKeepalive bool
sentLastMinuteHandhsake bool
persistentKeepaliveInterval uint32


MessageInitiation
MessageResponse
  timersAnyAuthenticatedPacketTraversal
  timersAnyAuthenticatedPacketReceived
MessageResponse
  timersSessionDerived
  timersHandshakeComplete
  sendKeepalive
timersDataSent
timersAnyAuthenticatedPacketSent
timersHandshakeInitiated

Keepalive timeout gets bumped on timersDataReceived

map[PK]Peer


MaxSegmentSize = (1 << 16) - 1  // UDP datagram limit
// Windows: 2048 - 32
// iOS: 1700

MaxTimerHandshakes = RekeyAttemptTime / RekeyTimeout
HandshakeInitiationRate: 20ms

Min/max message sizes

Implement HMAC-based KDF functions like in noise-helpers.go?

Replay + flood prevention
On init message check (ConsumeMessageInititation)
replay := !timestamp.after(handshake.last_timestamp)
flood := time.since(handshake.last_initiation_consumption) <= HandshakeInitiationRate (20ms)

---

